<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="retwisj">
  <title>Retwis-J Tutorial</title>
  
  <para>The Spring Data Redis - Retwis-J sample project show-cases a simple, Twitter-like clone built on top of Redis using Spring Data Redis.
  It is inspired by the original Redis example, <ulink url="https://redis.io/topics/twitter-clone">Retwis</ulink>. In short, it demos a simple, social-like messaging service
  based entirely on Redis.
	</para>

  
  <section id="retwisj:requirements">
    <title>Requirements</title>
    
    <para>To succesfully build and run RetwisJ, one needs:</para>
    <itemizedlist>
      <listitem>JDK 6.0</listitem>
      <listitem>Redis 2.4.x (Redis 2.2.x/2.0.x should work as well)</listitem>
      <listitem>Spring Data Redis 1.0 or higher</listitem>
      <listitem>A servlet 2.4 container (such as Tomcat 6) </listitem>
    </itemizedlist>
    
    <para>The version numbers above have been used to develop and test the demo. Other versions (especially higher ones) may or may not work.</para>
    
    <para>It is assumed that users of this tutorial have a basic knowledge of object-oriented design, Java, Spring, JSP, Java web applications and 
    <ulink url="https://redis.io/documentation">Redis</ulink> in particular.</para>
  </section>

  <section id="retwisj:setup">
    <title>Setup</title>
    
    <para>RetwisJ uses <ulink url="https://gradle.org/">Gradle</ulink> as its build system. To build the artifact, simply type at the command line:</para>
    <programlisting>gradlew war</programlisting>
    <para>which will create a WAR ready to be deployed into a container.</para>
    
    <note>If Gradle is installed, one can use <literal>gradle</literal> instead of <literal>gradlew</literal> in the command above.</note>
    
    <para>Once the WAR is created, deploy it into your container of choice and access it using a web browser (typically by accessing 
    <ulink url="http://localhost:8080/retwisj">http://localhost:8080/retwisj</ulink>). Goes without saying that before accessing the application, Redis should be started.</para>
  </section>

  <section id="retwisj:structure">
    <title>Redis Data Layout</title>
    
    <para>For a detailed introduction to Redis and how it can be used as a datastore for Twitter, take a look at the original Retwis 
    <ulink url="https://redis.io/topics/twitter-clone">documentation</ulink>. This document will describe the RetwisJ data structure without going into details of the
    various Redis features.</para>
    
    <para>To better understand the data layout, it helps to identify the main "domain" objects inside RetwisJ. In its current form, RetwisJ allows <emphasis>users</emphasis> to be 
    created, to post <emphasis>messages</emphasis>, to <emphasis>follow</emphasis> and be <emphasis>followed</emphasis> by other users. Each user automatically sees the <emphasis>posts</emphasis> of the
    ones she follows but also see other users posts from the <emphasis>timeline</emphasis>. Each italic word represents a "domain" object and its relationship to other objects that need to be represented
     in Redis.</para>
    
    <para>With a "traditional" database, one would use tables and indexes and so on however Redis is not a RDBMS rather, it is a key-value store. That is, it allows simple values (called strings
    in Redis terminology), lists, sets and sorted or z-sets to be stored under a unique key. So rather the storing data in a certain table at a certain id, we can store data directly under a key
    (using a key pattern of choice for easy retrieval) and take advantage of the various Redis key types. Again, for more details, see the "Data Layout" section in Retwis 
    <ulink url="https://redis.io/topics/twitter-clone">docs</ulink>.</para>
    
    <para>The user data (name and password) is stored in a hash (or a map). To generate the key for each new user, a dedicated counter is used (called <literal>global:uid</literal>); thanks to Redis atomic operations,
    the key can be simply incremented to generate a new user id (uid). We can now store the user data under the key <literal>uid:[uid]</literal> where <literal>[uid]</literal> represents
    the value generated by the <literal>global:uid</literal> key. For example, with two users "springrod" and "costinl", Redis will contain the following keys:</para>
    
    <table id="key-example-1" pgwide="1">
      <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" align="center"/>
          <colspec colname="c2" colwidth="1*" align="center"/>
          <colspec colname="c3" colwidth="2*" align="center"/>
          <thead>
            <row>
              <entry>Key Name</entry>
              <entry>Type</entry>
              <entry>Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>global:uid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry><literal>uid:1</literal></entry>
              <entry>hash</entry>
              <entry>{name: springrod, pass: interface21}</entry>
            </row>
            <row>
              <entry><literal>uid:2</literal></entry>
              <entry>hash</entry>
              <entry>{name: costinl, pass: secret}</entry>
            </row>

         </tbody>
      </tgroup>
    </table>
    
    <para>The uid is used internally to store and lookup all user information but we need to store also the relationship between the username and its internal uid - so for example, when a user logs on we 
    can 
    find the uid for the user name. A simple way to do that is to create a <emphasis>lookup</emphasis> or reverse key that relies on the username as the key and the uid as the value, such as 
    <literal>user:[name]:uid</literal>. We can also add a key that holds the names of all users for easy retrieval - we will use a list for that called <literal>users</literal>.
    Following our example above, the layout becomes:</para>

    <table id="key-example-2" pgwide="1">
      <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" align="center"/>
          <colspec colname="c2" colwidth="1*" align="center"/>
          <colspec colname="c3" colwidth="2*" align="center"/>
          <thead>
            <row>
              <entry>Key Name</entry>
              <entry>Type</entry>
              <entry>Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>global:uid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry><literal>uid:1</literal></entry>
              <entry>hash</entry>
              <entry>{name: springrod, pass: interface21}</entry>
            </row>
            <row>
              <entry><literal>uid:2</literal></entry>
              <entry>hash</entry>
              <entry>{name: costinl, pass: secret}</entry>
            </row>
            <row>
              <entry><literal>user:springrod:uid</literal></entry>
              <entry>string</entry>
              <entry>1</entry>
            </row>
            <row>
              <entry><literal>user:costinl:uid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry><literal>users</literal></entry>
              <entry>list</entry>
              <entry>{1, 2}</entry>
            </row>
         </tbody>
      </tgroup>
    </table>

    <para>The posts can be stored in a similar way - we can use a key (<literal>global:pid</literal>) as a counter to generate the post id (pid) and save the post content information (content, data and author) in a hash (<literal>pid:[pid]</literal>. We can use a list to store the posts for each user or rather their IDs (pids) - say under <literal>uid:[uid]:posts</literal> and all posts under the
    <literal>timeline</literal> key:</para>
    
    <table id="key-example-3" pgwide="1">
      <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" align="center"/>
          <colspec colname="c2" colwidth="1*" align="center"/>
          <colspec colname="c3" colwidth="2*" align="center"/>
          <thead>
            <row>
              <entry>Key Name</entry>
              <entry>Type</entry>
              <entry>Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>global:pid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry><literal>pid:1</literal></entry>
              <entry>hash</entry>
              <entry>{content: Hello World, time: 1301931414757, uid: 1}</entry>
            </row>
            <row>
              <entry><literal>pid:2</literal></entry>
              <entry>hash</entry>
              <entry>{content: Working on some cool stuff, time: 1301931414897, uid: 1}</entry>
            </row>
            <row>
              <entry><literal>uid:1:posts</literal></entry>
              <entry>list</entry>
              <entry>{1, 2}</entry>
            </row>
            <row>
              <entry><literal>uid:2:posts</literal></entry>
              <entry>list</entry>
              <entry>{3}</entry>
            </row>
            <row>
              <entry><literal>timeline</literal></entry>
              <entry>list</entry>
              <entry>{1, 2, 3}</entry>
            </row>
         </tbody>
      </tgroup>
    </table>    
    
    <para>The same approach can be used to store relationship between users that follow each other. Using the names above, costinl following springrod can be mapped through the 
    <literal>uid:[uid]:following</literal> and <literal>uid:[uid]:followers</literal> to indicate the users a certain uid follows or is followed by:</para>
    
    <table id="key-example-4" pgwide="1">
      <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" align="center"/>
          <colspec colname="c2" colwidth="1*" align="center"/>
          <colspec colname="c3" colwidth="2*" align="center"/>
          <thead>
            <row>
              <entry>Key Name</entry>
              <entry>Type</entry>
              <entry>Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>global:pid</literal></entry>
              <entry>string</entry>
              <entry>3</entry>
            </row>
            <row>
              <entry><literal>pid:1</literal></entry>
              <entry>hash</entry>
              <entry>{content: Hello World, time: 1301931414757, uid: 1}</entry>
            </row>
            <row>
              <entry><literal>pid:2</literal></entry>
              <entry>hash</entry>
              <entry>{content: Working on some cool stuff, time: 1301931414897, uid: 1}</entry>
            </row>
            <row>
              <entry><literal>pid:3</literal></entry>
              <entry>hash</entry>
              <entry>{content: Checking out RetwisJ, time: 1301931454897, uid: 2}</entry>
            </row>
            <row>
              <entry><literal>uid:1:posts</literal></entry>
              <entry>list</entry>
              <entry>{1, 2}</entry>
            </row>
            <row>
              <entry><literal>uid:2:posts</literal></entry>
              <entry>list</entry>
              <entry>{3}</entry>
            </row>
            <row>
              <entry><literal>timeline</literal></entry>
              <entry>list</entry>
              <entry>{1, 2, 3}</entry>
            </row>          
            <row>
              <entry><literal>uid:1:followers</literal></entry>
              <entry>set</entry>
              <entry>{2}</entry>
            </row>
            <row>
              <entry><literal>uid:1:following</literal></entry>
              <entry>set</entry>
              <entry>{1}</entry>
            </row>
         </tbody>
      </tgroup>
    </table>
        
    <para>Since a user following others does see not only her own posts but also of the ones she follows, we add a new key <literal>uid:[uid]:timeline</literal> similar in functionality to the
    <literal>timeline</literal> key, representing the "user post view" or the user timeline.</para>
    
    <para>Just like in the original Retwis, RetwisJ does not rely on Http Session to identify its authenticated users - rather it tracks each user through a dedicated cookie containing a unique random 
    value. Each time a user susccesfully logs in, the tracking value is generated, stored under <literal>uid:[uid]:auth</literal> and <literal>auth:[generated-string]</literal> as reverse key and sent 
    as a cookie to the client. On each request, if the cookie is present, the app looks up the associated uid and identifies the user.</para>
    
    <para>To wrap everything up, the Redis store can look as follows:</para>
    
    <table id="key-example-5" pgwide="1">
      <tgroup cols="4">
          <colspec colname="c1" colwidth="1*" align="center"/>
          <colspec colname="c2" colwidth="1*" align="center"/>
          <colspec colname="c3" colwidth="2*" align="center"/>
          <colspec colname="c4" colwidth="4*" align="center"/>
          <spanspec spanname="all" namest="c1" nameend="c4" colsep="0" align="center" />
          <thead>
            <row>
              <entry>Key Name</entry>
              <entry>Type</entry>
              <entry>Value</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row rowsep="0">
              <entry spanname="all"><emphasis><![CDATA[User-related keys]]></emphasis></entry>
            </row>
            <row>
              <entry><literal>global:uid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
              <entry>Global user id (uid) counter</entry>
            </row>
            <row>
              <entry><literal>uid:1</literal></entry>
              <entry>hash</entry>
              <entry>{name: springrod, pass: interface21}</entry>
              <entry>User info</entry>
            </row>
            <row>
              <entry><literal>uid:2</literal></entry>
              <entry>hash</entry>
              <entry>{name: costinl, pass: secret}</entry>
              <entry>User info</entry>
            </row>
            <row>
              <entry><literal>user:springrod:uid</literal></entry>
              <entry>string</entry>
              <entry>1</entry>
              <entry>username -> uid association</entry>
            </row>
            <row>
              <entry><literal>user:costinl:uid</literal></entry>
              <entry>string</entry>
              <entry>2</entry>
              <entry>username -> uid association</entry>
            </row>
            <row>
              <entry><literal>users</literal></entry>
              <entry>list</entry>
              <entry>{1, 2}</entry>
              <entry>List of "active" users</entry>
            </row>          
            <row>
              <entry><literal>uid:1:followers</literal></entry>
              <entry>set</entry>
              <entry>{2}</entry>
              <entry>Followers for the user 1 (springrod)</entry>
            </row>
            <row>
              <entry><literal>uid:2:following</literal></entry>
              <entry>set</entry>
              <entry>{1}</entry>
              <entry>Users followed by user 2 (costinl)</entry>
            </row>          
            <row>
              <entry><literal>uid:2:auth</literal></entry>
              <entry>string</entry>
              <entry>{3b7b0677...}</entry>
              <entry>uid -> auth key. Random string used for authenticating user 2 (costinl)</entry>
            </row>          
            <row>
              <entry><literal>auth:3b7b0677...</literal></entry>
              <entry>string</entry>
              <entry>{2}</entry>
              <entry>auth key -> uid</entry>
            </row>          

            <row rowsep="0">
              <entry spanname="all"><emphasis><![CDATA[Post-related keys]]></emphasis></entry>
            </row>
            <row>
              <entry><literal>global:pid</literal></entry>
              <entry>string</entry>
              <entry>4</entry>
              <entry>Global post id (pid) counter</entry>
            </row>
            <row>
              <entry><literal>pid:1</literal></entry>
              <entry>hash</entry>
              <entry>{content: Hello World, time: 1301931414757, uid: 1}</entry>
              <entry>Post 1 data</entry>
            </row>
            <row>
              <entry><literal>pid:2</literal></entry>
              <entry>hash</entry>
              <entry>{content: Working on some cool stuff, time: 1301931414897, uid: 1}</entry>
              <entry>Post 2 data</entry>
            </row>
            <row>
              <entry><literal>pid:3</literal></entry>
              <entry>hash</entry>
              <entry>{content: Checking out RetwisJ, time: 1301931454897, uid: 2}</entry>
              <entry>Post 3 data</entry>
            </row>
            <row>
              <entry><literal>pid:4</literal></entry>
              <entry>hash</entry>
              <entry>{content: Getting stuff done, time: 1301933414897, uid: 1}</entry>
              <entry>Post 4 data</entry>
            </row>

            <row>
              <entry><literal>uid:1:posts</literal></entry>
              <entry>list</entry>
              <entry>{1, 2, 4}</entry>
              <entry>User 1 (springrod) posts</entry>
            </row>
            <row>
              <entry><literal>uid:1:timeline</literal></entry>
              <entry>list</entry>
              <entry>{1, 2, 4}</entry>
              <entry>User 1 (springrod) timeline - identical to uid:1:posts if user does not follow other users</entry>
            </row>
            <row>
              <entry><literal>uid:2:posts</literal></entry>
              <entry>list</entry>
              <entry>{3}</entry>
              <entry>User 2 (costinl) posts</entry>
            </row>
            <row>
              <entry><literal>uid:2:timeline</literal></entry>
              <entry>list</entry>
              <entry>{3, 4}</entry>
              <entry>User 2 (costinl) timeline - contains the user posts and all the new posts of the users that are followed</entry>
            </row>
            <row>
              <entry><literal>timeline</literal></entry>
              <entry>list</entry>
              <entry>{1, 2, 3}</entry>
              <entry>List of all "active" posts</entry>
            </row>          
         </tbody>
      </tgroup>
    </table>
    
  </section>

  <section id="retwisj:design">
    <title>Application Design</title>

    <para>RetwisJ structure is fairly straight-forward, the application consisting of two layers: the web layer (package
    <literal>org.springframework.data.redis.sample.retwisj.web</literal>) and the persistence layer (package 
    <literal>org.springframework.data.redis.sample.retwisj.redis</literal>). The <emphasis>domain</emphasis> objects is available under
    package <literal>org.springframework.data.redis.sample.retwisj</literal>.</para>
    
    <section id="retwisj:design:web">
      <title>Web Layer</title>
      
      <sidebar>
         <title>What about other web frameworks?</title>
         
         <para>The sample was specifically created for developers with a Spring background hence the choice for Spring MVC.
         In the same vein, while JSP might not be the best choice, the majority of developers have been exposed to them. Note that
         the purpose of the sample is not to use the latest technologies but rather show-case the usage of Spring Data Redis.</para>
      </sidebar>
      
      <para>RetwisJ web layer is built on top of Spring 3.x 
      <ulink url="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/mvc.html">MVC framework</ulink> and 
      JSP as presentation technology. The web tier is intentionally kept to a minimum and simplified as much as possible as it is not the
      central piece of the application - developers unfamiliar with the two technologies aforementioned should be able to understand the
      code with minimal effort. It is recommended to use the excellent Spring 
      <ulink url="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/mvc.html">documentation</ulink> for
      more information on Spring MVC.</para>
      
      <para>The entire RetwisJ web front is handled by the <literal>RetwisJController</literal>, a annotation-based 
      <ulink url="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-controller">controller</ulink> that handles the various web requests and model population. Its methods map the actions available to the application: timeline, 
      user mentions, user posts and so forth. The methods of interest are <emphasis>posts</emphasis> and <emphasis>mentions</emphasis>
      (similar in structure), which handle saving and loading of posts.</para>
      
      <para>The rendering is handled through by JSP pages under <literal>WEB-INF/jsp</literal>. The bulk of the work, such as listing the
      followers, the following network, users in commons, posts and so on is handled through the JSP fragments under 
      <literal>WEB-INF/templates</literal>, namely <literal>posts.jspf</literal> and <literal>network.jspf</literal>.</para>
      
      <para>Just like the original Retwis, RetwisJ does not rely on Servlet sessions for user authentication, rather it uses cookie tracking.
      <classname>CookieInterceptor</classname>, a Spring MVC interceptor handles that by verifying the cookies of each new request and
      setting the authentication details. For production environments, we strongly recommend using a dedicated, mature solution such as 
      <ulink url="https://docs.spring.io/spring-security/site/">Spring Security</ulink> - the sample intent is to showcases the use of
      Redis in an easy fashion, without introducing other dependencies.</para>
      
      <para>For internationalization (i18n), RetwisJ relies on Spring MVC support, namely <literal>ResourceBundleMessageSource</literal> and
      <literal>CookieLocaleResolver</literal> - see 
      <ulink url="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-localeresolver">this</ulink> 
      section in the reference documentation for more information.</para>
    </section>
    
    <section id="retwisj:design:persistence">
      <title>Persistence</title>
      
      <para>The Redis interaction is handled through <classname>RetwisRepository</classname> class that demos many of the Spring Key Redis
      classes, such as the atomic counters, collection abstractions, the template but also the SORT/GET pattern for avoid the dreaded 
      <ulink url="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem">n+1</ulink> problem.</para>
      
      <para>To interact with the post and user counter, <classname>RetwisRepository</classname> uses two <literal>RedisAtomicLong</literal>
      which, just like <literal>java.util.concurrent.AtomicLong</literal> classes, allow numbers to be manipulated in an atomic fashion on top
      of Redis.</para>
      
      <para>Since the <emphasis>users</emphasis> and <emphasis>timeline</emphasis> entries are mapped as lists, they can accessed through the
      Redis collection abstraction; in this case <literal>RedisList</literal> interface. This way, items can be loaded and saved through the
      familiar <literal>Collection</literal> interface, without having to resort to Redis commands. In fact, the Redis collections are used
      to interact with the user network and execute operations on it. For example, the code for finding out the common followers of two 
      users looks as follows:</para>
      
      <programlisting language="java"><![CDATA[private RedisSet<String> following(String uid) {
   return new DefaultRedisSet<String>(KeyUtils.following(uid), template);
}
      
public Collection<String> commonFollowers(String uid, String targetUid) {
   RedisSet<String> tempSet = following(uid).
       intersectAndStore(following(targetUid),
       KeyUtils.commonFollowers(uid, targetUid));
        
   tempSet.expire(5, TimeUnit.SECONDS);

   return covertUidsToNames(tempSet.getKey());
}]]></programlisting>

    <para>The collections do not hold any date, they simply provide a <emphasis>view</emphasis> into the Redis store. So manipulating data this
    way, does not trigger any traffic between the application and the store. The method above has intersected two sets (the followers of the
    given users), stored the result in a dedicated set (with a small timeout to avoid the data lingering around) and then returns it to the
    user. The result is stored so that it can be properly parsed through <emphasis>convertUidToNames</emphasis> (see below) and to
    properly paginate through it. A potential improvement would be to check whether the set exists before creating a new one - this way reusing
    the result of a previous intersection.
    </para>
    
    <para>A common problem with any store is dealing efficiently with normalized data. In RetwisJ, to avoid data redundancy, the users and the
    posts are referred to by their ids (uid and pid); for example the keys <literal>uid:[uid]:posts</literal> contains a list of post ids (pids)
    not the actual posts. This means that when the posts for a user are loaded, the posts referred in the list need to be loaded. A simple
    approach would be simply iterate through the list and load each post one by one but clearly this is not efficient as it means a lot of
    (slow) IO activity between the application and the database.</para>
    
    <para>The best solution in such cases it to use the <emphasis>SORT/GET</emphasis> combination which allows data to be loaded based on its 
    key - more information <ulink url="https://redis.io/commands/sort">here</ulink>. SORT/GET can be seen as the equivalent of RDBMS 
    <emphasis>join</emphasis>. It is particularly handy when loading hashes since it permits field selection avoid loading of unnecessary
    data. Spring Data provides support for the <emphasis>SORT/GET</emphasis> pattern through its <methodname>sort</methodname> method and 
    the <literal>SortQuery</literal> and <literal>BulkMapper</literal> interface for querying and mapping the bulk result back to an object.
    Method <methodname>convertPidsToPosts</methodname> shows how these classes can be used load the posts by executing a 
    <emphasis>join</emphasis> over a hash.</para>
    
   </section>
  </section>
    
</chapter>